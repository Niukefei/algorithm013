学习笔记

算法与数据结构的基石：
任何高级的算法或者数据结构，到了最后都会转化成if else或者是for loop或者是递归，因为所用到的算法数据结构，都是最朴素的运算操作。最后学完或者写完，将它化繁为简之后，它的根本就是找到重复单元。

刻意练习：
如果学习完某节课之后，LeetCode上面的题只做一遍，这就是进行练习和刻意练习的最大误区。一遍是完全不够的。

ArrayList - 数组
随机访问，时间复杂度O(1)，插入删除需要移动数组元素（群移），平均要移一半的数组元素，时间复杂度是O(n)。

Linked List - 链表
链表的元素是class类。可包含成员变量：value，previous，next，head，tail。
Java中的linked list是双向链表(数据类型是泛型)。
链表插入删除的时间复杂度是O(1)，不会引起群移操作，访问头/尾节点时间复杂的是O(1)，访问其他元素时间复杂度是O(n)，线性访问操作。

--- 没有完美数据结构，各有优点。 ---

思考：一维有序的数据结构，加速的话，最常用的加速方法是升维变成二维，多了一个维度，就会有多了一级信息，多了一级信息，就可以很快得到一维中必须挨个走才能走到的元素。

SkipList - 跳表
跳表必须作用于一种有序的数据结构。（对于数据元素个数不多的情况，可以取代平衡树和二分查找）
查询的时间复杂度为O(logn)  。二分查找的时间复杂度。
维护成本相对较高，增加和删除可能需要改变更新索引，增加删除的时间复杂度会变成O(logn)。
空间复杂度是O(n)。

Stack - 栈
先入后出，添加/删除为O(1)，查询为O(n) 因为是无序的，需要遍历。
Java推荐在实际开发中直接使用Deque。

Queue - 队列
先入先出，添加/删除为O(1)，查询为O(n) 因为是无序的，需要遍历。

Deque - 双端队列
栈和队列的结合体，添加/删除为O(1)，查询为O(n) 因为是无序的，需要遍历。

Priority Queue - 优先级队列
插入操作O(1)
取出操作O(logN) - 按照元素的优先级取出
底层实现的数据结构较为多样和复杂可以用:heap 堆，bst 二叉搜索树，treap
