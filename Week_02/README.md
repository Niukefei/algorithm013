学习笔记
哈希表总结
哈希表用的就是数组按下标随机访问，时间复杂度为 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。
哈希函数，顾名思义，它是一个函数。可以把它定义成 hash(key)，其中 key 表示元素的键值(原始值)，hash(key) 的值表示经过散列函数计算得到的散列值。

散列函数设计的三点基本要求：
1. 散列函数计算得到的散列值是一个非负整数；(映射为数组下标)
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；(key相同，散列值相同)
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。(避免散列冲突)

解决散列冲突的方法：
1. 开放寻址法（线性探测，二次探测，双重散列）
优点：
散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且序列化起来比较简单。
缺点：
删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。所有的数据都存储在一个数组中，冲突的代价更高。

2. 链表法（就是升维）
优点：
链表法对内存的利用率比开放寻址法要高。
缺点：
对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且零散分布在内存中，不连续，对 CPU 缓存是不友好的。

Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。

基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

当然，如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。
如果使用基于链表的冲突解决方法，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。

哈希表的查找，删除，插入操作的时间复杂度都是O(1)。
