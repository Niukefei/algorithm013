学习笔记
BFS & DFS：
广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A*、IDA* 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。

广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。

广度：借助一个队列
深度：借助一个栈

两种搜索都是固化的一种程序，类似于模板一样，记住了就好。它的本质无非就是把所有的节点都访问一遍，按照访问的次序不一样，分为深度优先和广度优先。
写的过程中，可以用递归的方式，也可以用循环的方式来写。深度优先搜索用递归的方式程序比较简单，因为程序用系统自动去维护了一个函数调用栈。广度优先搜索的话程序没办法帮你维护queue这么一个数据结构，所以必须手动维护一个队列。

public class Solution {
    // DFS遍历使用递归
    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        dfs(root.right);
    }
    // 使用栈数据结构(系统自动帮我们维护就尽量不自己手动维护了)
    public void dfs_stack(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while (stack.Count != 0 || root != null) {
            while (root != null) {
                stack.Push(root);
                root = root.left;
            }
            root = stack.Pop();
            root = root.right;
        }
    }

    // BFS遍历使用队列数据结构
    public void bfs(TreeNode root) {
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);
        while (queue.Count != 0) {
            TreeNode temp = queue.Dequeue();
            if (temp.left != null) queue.Enqueue(temp.left);
            if (temp.right != null) queue.Enqueue(temp.right);
        }
    }
}

贪心算法：
贪心算法与动态规划的不同之处在于它对每个子问题的解决方案都作出选择，不能回退 (当前最优)。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择 (选择全局最优)，有回退功能。

子问题最优解就是最优子结构。

贪心算法难就难在你怎么证明它是可以用贪心的，以及贪心的角度可能不一样。有时候可以正常去用贪心，有的时候必须把问题稍微转化一下，再进行所谓的贪心求解，有的时候回从前往后贪心 (常规套路)，有的时候要从后往前贪心。

贪心算法比较难想 (指此问题是否可以用贪心解决)，但是想到之后程序非常简单。

二分查找：
1.什么是二分查找？
二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。
2.时间复杂度分析？
1.时间复杂度
假设数据大小是n，每次查找后数据都会缩小为原来的一半，最坏的情况下，直到查找区间被缩小为空，才停止。所以，每次查找的数据大小是：n，n/2，n/4，…，n/(2^k)，…，这是一个等比数列。当n/(2^k)=1时，k的值就是总共缩小的次数，也是查找的总次数。而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就是O(k)。通过n/(2^k)=1，可求得k=log2n，所以时间复杂度是O(logn)。
2.认识O(logn)
①这是一种极其高效的时间复杂度，有时甚至比O(1)的算法还要高效。为什么？
②因为logn是一个非常“恐怖“的数量级，即便n非常大，对应的logn也很小。比如n等于2的32次方，也就是42亿，而logn才32。
③由此可见，O(logn)有时就是比O(1000)，O(10000)快很多。
有三种方法查找循环有序数组
 一、
 1. 找到分界下标，分成两个有序数组
 2. 判断目标值在哪个有序数据范围内，做二分查找
 二、
 1. 找到最大值的下标 x;
 2. 所有元素下标 +x 偏移，超过数组范围值的取模;
 3. 利用偏移后的下标做二分查找；
 4. 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。
 两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。
 复杂度有点高，能否优化呢？
 三、
我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。(不管分界点在哪，都会这样)
 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；
 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；
 如果目标元素在有序数组范围中，使用二分查找；
 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。
 时间复杂度为 O(logN)。
